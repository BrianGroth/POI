<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nearby Explorer</title>
    <style>
        /* Basic Reset & Modern Font Stack */
        :root {
            --primary-bg: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #212529;
            --muted-text: #6c757d;
            --accent-color: #007bff; /* Blue */
            --link-color: #0056b3; /* Darker blue for links */
            --card-shadow: 0 4px 8px rgba(0,0,0,0.1);
            --border-radius: 8px;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6;
            background-color: var(--primary-bg);
            color: var(--text-color);
            padding: 1rem;
        }

        /* App Container */
        #app-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Header/Title */
        h1 {
            text-align: center;
            color: var(--accent-color);
            margin-bottom: 1.5rem;
            font-weight: 600;
        }

        /* Status Messages */
        #status-message {
            text-align: center;
            padding: 2rem 1rem;
            font-size: 1.1rem;
            color: var(--muted-text);
            min-height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Loading Indicator */
        .loading::after {
            content: '...';
            display: inline-block;
            animation: loading-dots 1.4s infinite;
            animation-timing-function: ease-in-out;
        }
        @keyframes loading-dots {
            0%, 100% { opacity: 0; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1); }
        }


        /* POI Grid Layout */
        #poi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem; /* Increased gap slightly */
        }

        /* Individual POI Tile Styling */
        .poi-tile {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        .poi-tile:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        .poi-tile img {
            width: 100%;
            height: 180px;
            object-fit: cover;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
            margin: -1rem -1rem 1rem -1rem;
            background-color: #eee;
            border-bottom: 1px solid #eee;
        }

         .poi-tile .no-image {
             display: none;
         }

        /* Title Styling */
        .poi-tile h3 {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--accent-color); /* Keep title color distinct */
            margin-bottom: 0.25rem; /* Reduced margin */
        }
        .poi-tile h3 a {
            text-decoration: none;
            color: inherit; /* Inherit color from h3 */
        }
         .poi-tile h3 a:hover {
             text-decoration: underline;
             color: var(--link-color); /* Darker blue on hover */
         }

        /* Distance Styling */
        .poi-distance {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--muted-text);
            margin-bottom: 0.5rem;
        }

        /* Description Styling */
        .poi-tile p.poi-description {
            font-size: 0.95rem;
            color: var(--text-color); /* Slightly darker than distance */
            flex-grow: 1;
            margin-bottom: 1rem; /* Space before map link */
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 4; /* Limit lines */
            -webkit-box-orient: vertical;
        }

        .poi-tile p.no-description {
             font-style: italic;
             color: var(--muted-text);
        }

        /* Map Link Styling */
        .poi-map-link {
             display: inline-block;
             padding: 0.5rem 1rem;
             background-color: var(--accent-color);
             color: white;
             text-decoration: none;
             border-radius: calc(var(--border-radius) / 2);
             text-align: center;
             font-weight: 500;
             transition: background-color 0.2s ease;
             margin-top: auto; /* Push to bottom if description is short */
        }
        .poi-map-link:hover {
            background-color: var(--link-color);
        }

    </style>
</head>
<body>

    <div id="app-container">
        <h1>Nearby Explorer</h1>
        <div id="status-message">Initializing...</div>
        <div id="poi-grid">
            </div>
    </div>

    <script>
        const statusElement = document.getElementById('status-message');
        const gridElement = document.getElementById('poi-grid');
        const OVERPASS_API_URL = 'https://overpass-api.de/api/interpreter';
        const WIKIDATA_SPARQL_URL = 'https://query.wikidata.org/sparql';
        const MAX_POIS_TO_DISPLAY = 6;
        const SEARCH_RADIUS_METERS = 1000; // Search within 1km

        let userCoords = null; // Store user coordinates globally

        // --- Helper Functions ---

        // Calculate distance between two lat/lon points using Haversine formula
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const φ1 = lat1 * Math.PI / 180; // φ, λ in radians
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Distance in meters
        }

        // Format distance in meters into a user-friendly string (miles/km or feet/m)
        function formatDistance(distanceMeters) {
            if (isNaN(distanceMeters)) return ""; // Handle cases where distance couldn't be calculated

            const metersToFeet = 3.28084;
            const metersToMiles = 0.000621371;

            if (distanceMeters < 1000) { // Less than 1km, use feet and meters
                const feet = Math.round(distanceMeters * metersToFeet);
                const meters = Math.round(distanceMeters);
                return `approx. ${feet} ft (${meters} m)`;
            } else { // 1km or more, use miles and kilometers
                const miles = (distanceMeters * metersToMiles).toFixed(1);
                const kilometers = (distanceMeters / 1000).toFixed(1);
                return `approx. ${miles} mi (${kilometers} km)`;
            }
        }

        // Generate appropriate Google Maps URL based on basic OS detection
        function generateMapLink(poiLat, poiLon, poiName) {
            let mapUrl = `https://www.google.com/maps/search/?api=1&query=${poiLat},${poiLon}`; // Web fallback
            const encodedName = encodeURIComponent(poiName);

            try {
                // Use UserAgentData if available (more modern)
                if (navigator.userAgentData) {
                    const platform = navigator.userAgentData.platform.toLowerCase();
                    if (platform.includes("android")) {
                        mapUrl = `geo:${poiLat},${poiLon}?q=${poiLat},${poiLon}(${encodedName})`;
                    } else if (platform.includes("ios") || platform.includes("ipad") || platform.includes("iphone") || platform.includes("ipod") || (platform.includes("mac") && navigator.maxTouchPoints > 1)) { // Check for touch capability on Mac as proxy for potential iOS app support
                         mapUrl = `comgooglemaps://?q=${poiLat},${poiLon}&zoom=15`; // Simple query
                    }
                } else {
                    // Fallback to UserAgent string sniffing (less reliable)
                    const userAgent = navigator.userAgent.toLowerCase();
                     if (/android/i.test(userAgent)) {
                         mapUrl = `geo:${poiLat},${poiLon}?q=${poiLat},${poiLon}(${encodedName})`;
                    } else if (/iphone|ipad|ipod/i.test(userAgent)) {
                         mapUrl = `comgooglemaps://?q=${poiLat},${poiLon}&zoom=15`;
                    }
                }
            } catch (e) {
                console.warn("Could not detect OS for map link generation, using web fallback.", e);
            }
            return mapUrl;
        }


        // --- Core Logic Functions ---

        // 1. Get User Location
        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Geolocation is not supported by your browser.'));
                    return;
                }
                statusElement.textContent = 'Requesting location permission...';
                statusElement.classList.add('loading');
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        statusElement.textContent = 'Location acquired.';
                        statusElement.classList.remove('loading');
                        userCoords = { // Store globally
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };
                        resolve(userCoords);
                    },
                    (error) => {
                        let message = 'Could not get location. ';
                        switch(error.code) {
                            case error.PERMISSION_DENIED: message += "Permission denied."; break;
                            case error.POSITION_UNAVAILABLE: message += "Location information is unavailable."; break;
                            case error.TIMEOUT: message += "The request to get user location timed out."; break;
                            default: message += "An unknown error occurred."; break;
                        }
                        reject(new Error(message));
                    },
                    { enableHighAccuracy: false, timeout: 10000, maximumAge: 60000 }
                );
            });
        }

        // 2. Fetch Nearby POIs from OpenStreetMap (Overpass API)
        async function fetchNearbyPOIs(latitude, longitude) {
            statusElement.textContent = 'Finding nearby places...';
            statusElement.classList.add('loading');

            // Updated query to request coordinates explicitly using `out center;`
            // Increased limit slightly to get more candidates for distance sorting
            const query = `
                [out:json][timeout:25];
                (
                  nwr["name"]["tourism"](around:${SEARCH_RADIUS_METERS},${latitude},${longitude});
                  nwr["name"]["historic"](around:${SEARCH_RADIUS_METERS},${latitude},${longitude});
                  nwr["name"]["leisure"="park"](around:${SEARCH_RADIUS_METERS},${latitude},${longitude});
                  nwr["name"]["amenity"="place_of_worship"](around:${SEARCH_RADIUS_METERS},${latitude},${longitude});
                  nwr["name"]["natural"="peak"](around:${SEARCH_RADIUS_METERS},${latitude},${longitude});
                );
                out center ${MAX_POIS_TO_DISPLAY * 4}; >; out skel qt;
            `;

            try {
                const response = await fetch(OVERPASS_API_URL, {
                    method: 'POST',
                    body: 'data=' + encodeURIComponent(query),
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
                });

                if (!response.ok) throw new Error(`Overpass API error: ${response.status}`);
                const data = await response.json();
                statusElement.textContent = 'Processing places...';

                const pois = data.elements
                    .filter(el => el.tags && el.tags.name && (el.lat || el.center?.lat)) // Must have name and coordinates
                    .map(el => {
                        const coords = el.type === 'node' ? { lat: el.lat, lon: el.lon } : { lat: el.center.lat, lon: el.center.lon };
                        // Calculate distance immediately if userCoords are available
                        const distance = userCoords ? calculateDistance(userCoords.latitude, userCoords.longitude, coords.lat, coords.lon) : null;
                        return {
                            id: el.id,
                            name: el.tags.name,
                            wikidataId: el.tags.wikidata,
                            latitude: coords.lat,
                            longitude: coords.lon,
                            distance: distance // Store distance in meters
                        };
                    })
                    // Deduplicate based on name AND wikidataId (better than just name)
                    .filter((poi, index, self) =>
                        index === self.findIndex((p) => p.name === poi.name && p.wikidataId === poi.wikidataId)
                    );

                console.log(`Found ${pois.length} potential POIs with coordinates from Overpass.`);
                return pois;

            } catch (error) {
                console.error('Error fetching from Overpass:', error);
                throw new Error('Failed to fetch nearby places from OpenStreetMap.');
            }
        }

        // 3. Fetch Details (Description, Image, Wikipedia URL) from Wikidata
        async function fetchWikidataDetails(wikidataId) {
            if (!wikidataId) return null;

            // Updated SPARQL query to include Wikipedia link (sitelink)
            const sparqlQuery = `
                SELECT ?description ?image ?wikipediaUrl WHERE {
                  BIND(wd:${wikidataId} AS ?item)
                  OPTIONAL { ?item schema:description ?description FILTER(LANG(?description) = "en"). }
                  OPTIONAL { ?item wdt:P18 ?image . }
                  OPTIONAL {
                    ?wikipediaUrl schema:about ?item ;
                                  schema:isPartOf <https://en.wikipedia.org/> ;
                                  schema:inLanguage "en" .
                  }
                } LIMIT 1
            `;

            const url = `${WIKIDATA_SPARQL_URL}?query=${encodeURIComponent(sparqlQuery)}&format=json`;

            try {
                const response = await fetch(url, { headers: { 'Accept': 'application/sparql-results+json' } });
                if (!response.ok) {
                    console.warn(`Wikidata query failed for ${wikidataId}: ${response.status}`);
                    return null;
                }
                const data = await response.json();

                if (data.results.bindings.length > 0) {
                    const binding = data.results.bindings[0];
                    return {
                        description: binding.description?.value,
                        imageUrl: binding.image?.value,
                        wikipediaUrl: binding.wikipediaUrl?.value // Extract Wikipedia URL
                    };
                }
                return null;

            } catch (error) {
                console.warn(`Error fetching Wikidata details for ${wikidataId}:`, error);
                return null;
            }
        }

        // 4. Display POIs in the Grid
        function displayPOIs(pois) {
            gridElement.innerHTML = ''; // Clear previous results

            if (!pois || pois.length === 0) {
                statusElement.textContent = 'No interesting places found nearby with details.';
                statusElement.classList.remove('loading');
                statusElement.style.display = 'block'; // Ensure status is visible
                return;
            }

            statusElement.style.display = 'none'; // Hide status when showing results

            pois.forEach(poi => {
                const tile = document.createElement('div');
                tile.className = 'poi-tile';

                // Image
                const image = document.createElement('img');
                 if (poi.details?.imageUrl) {
                     image.src = poi.details.imageUrl;
                     image.alt = `Image of ${poi.name}`;
                     // Basic error handling for broken images
                     image.onerror = () => image.classList.add('no-image');
                 } else {
                      image.classList.add('no-image'); // Hide if no URL initially
                 }
                 tile.appendChild(image);

                // Title (potentially linked to Wikipedia)
                const nameHeader = document.createElement('h3');
                if (poi.details?.wikipediaUrl) {
                    const wikiLink = document.createElement('a');
                    wikiLink.href = poi.details.wikipediaUrl;
                    wikiLink.textContent = poi.name;
                    wikiLink.target = "_blank"; // Open in new tab
                    wikiLink.rel = "noopener noreferrer";
                    nameHeader.appendChild(wikiLink);
                } else {
                    nameHeader.textContent = poi.name; // Display name without link
                }
                tile.appendChild(nameHeader);

                // Distance
                const distanceElement = document.createElement('div');
                distanceElement.className = 'poi-distance';
                distanceElement.textContent = formatDistance(poi.distance); // Format the distance
                tile.appendChild(distanceElement);

                // Description
                const description = document.createElement('p');
                description.className = 'poi-description'; // Add class for styling
                 if (poi.details?.description) {
                     description.textContent = poi.details.description;
                 } else {
                     description.textContent = 'No description available.';
                     description.classList.add('no-description');
                 }
                 tile.appendChild(description);

                // Google Maps Link
                if (poi.latitude && poi.longitude) {
                    const mapLink = document.createElement('a');
                    mapLink.className = 'poi-map-link';
                    mapLink.href = generateMapLink(poi.latitude, poi.longitude, poi.name);
                    mapLink.textContent = 'Open in Google Maps';
                    // Note: target="_blank" might not be needed for app URLs but doesn't hurt web fallback
                    mapLink.target = "_blank";
                    mapLink.rel = "noopener noreferrer";
                    tile.appendChild(mapLink);
                }

                gridElement.appendChild(tile);
            });
        }

        // --- Main Application Flow ---
        async function initApp() {
            try {
                // Get location first, store globally
                const location = await getUserLocation();

                // Fetch POIs (distance calculation now happens inside fetchNearbyPOIs)
                const nearbyPOIs = await fetchNearbyPOIs(location.latitude, location.longitude);

                if (nearbyPOIs.length === 0) {
                    statusElement.textContent = 'No places found nearby via OpenStreetMap.';
                    statusElement.classList.remove('loading');
                    return;
                }

                statusElement.textContent = 'Fetching details...';
                statusElement.classList.add('loading');

                // Fetch Wikidata details concurrently
                const detailedPOIs = await Promise.all(
                    nearbyPOIs
                        // Process only those with Wikidata IDs first for efficiency
                        .filter(poi => poi.wikidataId)
                        .map(async (poi) => {
                            const details = await fetchWikidataDetails(poi.wikidataId);
                            return { ...poi, details };
                        })
                );

                // Combine detailed POIs with those that didn't have Wikidata IDs (if any needed)
                // For now, we prioritize those with details. Add back others if needed.
                // const allProcessedPOIs = [...detailedPOIs, ...nearbyPOIs.filter(p => !p.wikidataId)];

                // Filter down to valid POIs (must have distance calculated) and sort them
                 const finalPOIs = detailedPOIs
                     .filter(poi => poi.distance !== null) // Ensure distance was calculated
                     .sort((a, b) => a.distance - b.distance) // Sort by distance, nearest first
                     .slice(0, MAX_POIS_TO_DISPLAY); // Take the closest ones

                displayPOIs(finalPOIs);

            } catch (error) {
                console.error('App initialization failed:', error);
                statusElement.textContent = `Error: ${error.message}`;
                statusElement.classList.remove('loading');
                gridElement.innerHTML = '';
            }
        }

        // Start the app once the DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);

    </script>

</body>
</html>